/**
 * Remark plugin: Convert "#### Parameters" sections generated by TypeDoc Markdown
 * into compact Markdown tables (Name | Type | Description | Default).
 *
 * Works on content produced by typedoc-plugin-markdown (docusaurus theme),
 * which renders parameters as h5 headings followed by an inline code paragraph
 * for the type and one or more paragraphs for the description.
 */
function parametersToTable() {
  return (tree) => {
    transformInParent(tree);
  };
}

function transformInParent(parent) {
  if (!parent || !parent.children || !Array.isArray(parent.children)) return;
  const children = parent.children;
  for (let i = 0; i < children.length; i++) {
    const node = children[i];
    // Recurse into subsections
    transformInParent(node);

    if (isHeadingWithText(node, 4, 'Parameters')) {
      // Collect parameter blocks until we hit a heading of depth <= 4 (e.g., Returns)
      const rows = [];
      let j = i + 1;
      while (j < children.length) {
        const n = children[j];
        if (n.type === 'heading' && n.depth <= 4) break;
        // Expect a parameter subheading (##### name)
        if (!isHeading(n, 5)) { j++; continue; }
        const name = plainText(n);
        j++;
        // Next should be a paragraph containing inlineCode for the type
        let type = '';
        let description = '';
        let defaultVal = '';
        if (j < children.length && children[j].type === 'paragraph') {
          const p = children[j];
          if (p.children && p.children.length === 1 && p.children[0].type === 'inlineCode') {
            type = p.children[0].value || '';
            // Try to split default: Type = Default
            const eqIdx = type.indexOf('=');
            if (eqIdx !== -1) {
              defaultVal = type.slice(eqIdx + 1).trim();
              type = type.slice(0, eqIdx).trim();
            }
            j++;
          }
        }
        // Accumulate description paragraphs until we hit next heading
        const descParts = [];
        while (j < children.length) {
          const dn = children[j];
          if (dn.type === 'heading') break;
          if (dn.type === 'paragraph') {
            descParts.push(plainText(dn));
          }
          j++;
        }
        description = descParts.join(' ').replace(/\s+/g, ' ').trim();
        rows.push({ name, type, description, defaultVal });
      }

      if (rows.length) {
        // Remove original parameter nodes we consumed
        const removeCount = j - (i + 1);
        if (removeCount > 0) children.splice(i + 1, removeCount);

        // Insert a Markdown table as mdast 'table' node
        const table = makeTableNode([
          ['Name', 'Type', 'Description', 'Default'],
          ...rows.map((r) => [
            escapePipes(r.name),
            codeInline(r.type || ''),
            escapePipes(r.description || ''),
            codeInline(r.defaultVal || ''),
          ]),
        ]);

        children.splice(i + 1, 0, table);
        // Skip over the inserted table
        i += 1;
      }
    }
  }
}

function isHeading(node, depth) {
  return node && node.type === 'heading' && node.depth === depth;
}
function isHeadingWithText(node, depth, text) {
  return isHeading(node, depth) && plainText(node).toLowerCase() === text.toLowerCase();
}
function plainText(node) {
  if (!node) return '';
  if (node.type === 'text') return node.value || '';
  const parts = [];
  const stack = [node];
  while (stack.length) {
    const n = stack.shift();
    if (!n) continue;
    if (Array.isArray(n.children)) stack.unshift(...n.children);
    if (n.type === 'text' || n.type === 'inlineCode' || n.type === 'code') {
      parts.push(n.value || '');
    }
  }
  return parts.join('');
}

function codeInline(text) {
  if (!text) return '';
  return '`' + text.replace(/`/g, '\\`') + '`';
}

function escapePipes(text) {
  return (text || '').replace(/\|/g, '\\|');
}

function makeTableNode(rows) {
  // Build an mdast table node
  const header = rows[0];
  const aligns = new Array(header.length).fill(null);
  const children = rows.map((cells, rowIdx) => ({
    type: 'tableRow',
    children: cells.map((cell) => ({
      type: 'tableCell',
      children: [{ type: 'text', value: cell }],
    })),
    data: rowIdx === 0 ? { hProperties: { className: 'params-table-header' } } : undefined,
  }));
  return { type: 'table', align: aligns, children };
}

module.exports = parametersToTable;

